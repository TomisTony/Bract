# Bract 总结

## Bract 和 React 有什么区别？
Bract 是 react 的简化版。其中包括了 react 的基础概念和功能，包括
- 自己的 createElement 来解析 JSX
- 虚拟 Dom，可以完成虚拟 Dom 之间的比较和更新，并最终应用到真实 Dom 上
- Fiber 的基本实现
  - Work in Progress Tree 和 Current Tree
  - 拆分虚拟 Dom，按照 DFS 的顺序遍历节点来比较虚拟 dom
  - 通过 requestIdleCallback 来暂停虚拟 Dom 的比较，让出时间片给高优先级任务
- FC、hooks TODO

## 自己的 createElement 是怎么回事



## 虚拟 DOM 是如何实现的


## Bract 的虚拟 DOM 对比原生 DOM 有什么优势
这个虚拟 Dom 跟 React 那边的虚拟 DOom 的核心作用是一致的，都是为了提高复杂页面渲染的性能。主要体现在以下方面：
- 减少 dom 操作次数
- 可以精准地对必要的组件进行更新

## 函数式组件是如何实现的
在我们适配函数式组件之前，我们都是直接一次性把整个 JSX 写完，然后统一对整个 JSX 渲染的。在我们适配函数式组件之后，我们终于可以分模块的形式来表示整个 DOM 了。

由于函数式组件内部也是以 JSX 的形式返回，所以本质上他和直接处理 JSX 没有什么不同，唯一需要注意的两点是：
- 函数式组件没有对应的 DOM，在实际的 DOM 中他是缺位的，如果直接使用 DevTools 查看当前页面的 DOM 的话，可以发现函数式组件内部返回的 JSX 直接代替了他的位置。
- 函数式组件作为一个 node，他的 children 的获得方法和直接写 JSX 不一样。直接写 JSX 获得其字节点的方式就是通过 props，即他的所有的子节点都存储在 props 里面；而函数式组件的子节点是需要通过执行函数来返回的。

这里需要注意的是，虽然我们不为函数式组件创建 DOM，这意味着实际上的 DOM tree 里是没有函数式组件这个节点的，但是在 Fiber tree 里面，函数式组件这个 node 是确实存在的。所以我们想要让我们原本的直接渲染 JSX 的逻辑来适配函数式组件的话，需要更改所有 Fiber 会和 DOM 发生交互的的地方：
- 我们在创建 DOM 节点的地方，查看当前的 node 是不是函数式组件，如果是的话，就跳过，因为我们不会为函数式组件创建 DOM，而是为他返回的内部的节点创建 DOM。
- 在根据 Fiber tree 修改 DOM 的地方也需要对函数式组件做特殊处理，具体点说就是，每次增添子节点或者删除节点的时候，我们需要向上或者向下查找到第一个拥有 DOM 的节点，因为那个节点才是 DOM  tree 中真实存在的节点，才能进行 DOM 操作。

## 函数式组件的逻辑和正常的 DOM 节点有什么不同（和之前直接渲染 JSX 有什么不同）
见 `函数式组件是如何实现的`

